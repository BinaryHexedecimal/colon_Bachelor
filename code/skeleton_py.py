from plot_py import *
from math_py import *
import numpy as np
import copy
import math
import scipy
from scipy import linalg
import skimage
from skimage import morphology as sk

def find_skeleton(colon, affine):
    """
    Transform the colon array into the anatomical coordiante system, and fill the holes generated during scaling with 1
    Then in this isotropical system, detect the centerline of colon.

    Parameters:
    ----------
    colon :        3D numpy array
                a binary array in voxel coordinate system
    affine :       4 X 4 numpy array 
                the affine array
    Returns:
    ----------
    skeleton_atm_arr: 3D numpy array
                binary array, with label 1 for skeleton
    
    origin :       1 X 3 numpy array. 
                The position of skeleton array[0,0,0] in the original anatomical coordinate system
            
    """

    colon_atm_points = (arr_2_atm(colon, affine)).astype(int)
    
    colon_atm_arr, origin = approximate_points_atm_to_arr(colon_atm_points)
    #fill the small holes generated by scaling
    colon_atm_arr = sk.binary_closing(colon_atm_arr)
    # detect skeleton
    skeleton_atm_arr = sk.skeletonize(colon_atm_arr, method = 'lee')

    if np.max(skeleton_atm_arr) == 255:
        skeleton_atm_arr = skeleton_atm_arr / 255
    return skeleton_atm_arr, origin 



def find_all_vertice(skeleton_arr):
    """
    Given a skeleton, find both endpoints and junctions

    Parameters:
    ----------
    skeleton_arr:    3D numpy array
                binary array, with label 1 for skeleton
    Returns:
    ----------
    endpoint_lst:   list of list of float  
               Endpoints refer to points with only one connectivity
               The outer list has various length, depending on the no. of endpoints
               Each inner list has 3 items, cooresponding to one endpoint's coordinates
    junction_lst:   list of list of float 
               Junction points refer to points with more than two connectivities
               The outer list has various length, depending on the no. of junctions
               Each inner list has 3 items, cooresponding to one junction's coordinates
            
    """    
    size = skeleton_arr.shape
    adjacent_arr = np.ones((3, 3, 3))
    adjacent_arr[1, 1, 1] = 0
    # no. of neighbours
    nb_no = scipy.ndimage.convolve(skeleton_arr, adjacent_arr, mode = 'constant', cval = 0.0)

    # junction 
    nb3_arr = np.zeros((size))
    nb3_arr[nb_no >= 3] = 1
    nb3_arr[skeleton_arr == 0] = 0
    junctions = np.argwhere(nb3_arr == 1) 
    junction_lst = junctions.tolist()
    
    # endpoint
    nb1_arr = np.zeros((size))
    nb1_arr[nb_no == 1] = 1
    nb1_arr[skeleton_arr == 0] = 0
    endpoints = np.argwhere(nb1_arr == 1) 
    endpoint_lst = endpoints.tolist()

    return endpoint_lst, junction_lst


def find_nb(point, skeleton_arr):
    """
    Find a point's neighbour(s) on skeleton
    Parameters:
    ----------
    point:      1 X 3 numpy array
             a point's coordinate
    skeleton_arr: 3D numpy array
             binary matrix with 1 for centerline
    Returns:
    ----------
    nb_lst:     list of list of integer
             the coordinates of all neighbour points
    """  
    assert skeleton_arr[point[0], point[1], point[2]] == 1
    i, j, k = point
    #print("point", point)
    nb_lst = []
    if i > 0 and j > 0 and k > 0:
        arr = skeleton_arr[i - 1:i + 2, j - 1:j + 2, k - 1:k + 2].copy()
        arr[1, 1, 1] = 0
        nbs = np.argwhere(arr == 1)
        nbs = nbs + np.array([i - 1, j - 1, k - 1])
        nb_lst = nbs.tolist()
    return nb_lst



def extend_edge(edge, vertice_lst, skeleton_arr, no_loop = True):
    """
    Given a (segment of) edge, extend the edge until meeting a junction or endpoint.
    Parameters:
    ----------
    edge:       list of list
              list of coordinates of points on an edge
              The initial edge must contains no less than two points 
              updated in each recursion
    vertice_lst:   list of list
              list of coordinates of vertices
    skeleton_arr:  3D numpy array
              binary matrix with 1 for centerline
    no_loop :     boolean
              defalted True
              set as False, once the edge ends at its starting points. Then the recursion is terminated.
              
    Returns:
    ----------
    The function does not return anything.
    Instead, two parameters <edge> and <no_loop> are updated during recursion
    """ 
    no_loop = True
    point = edge[-1]
    # check whether the edge starts from and ends at the same vertice, i.e., a loop  
    if point in vertice_lst and point == edge[0]:
        #print(f"has found a looooooop edge {edge}")
        no_loop = False
        pass
    # meet a vertice and edge will stop growing
    elif point in vertice_lst and point != edge[0]:
        pass
    # continue growing    
    else: 
        nbs = find_nb(point, skeleton_arr)
        if nbs[0] == edge[-2]:
            candidate = nbs[1]
        else:
            candidate = nbs[0]            
        edge.append(candidate)
        extend_edge(edge, vertice_lst, skeleton_arr, no_loop = True)


def find_edges(X_lst, vertice_lst, skeleton_arr):
    """
    Detect all edges that start from a vertice in X_lst
    If two or more edges share the same starting vertice and ending vertice, keep only the longest one and delete the others.
    ----------
    X_list:        list of list
                list of coordinates of points. We want to find all edges that originate from it.
    vertice_lst:     list of list
                list of coordinates of all vertices on skeleton
    skeleton_arr:    3D numpy array
                binary matrix with 1 for centerline
              
    Returns:
    ----------
    edge_lst_uniq :      list of list of list in integer  
                The outmost list contains edges, each of which is a list of points on this edge.
                The inner list is the coordinates of one point.
    edge_length_uniq:  list in interger
                contains the length of edges, in sequence coorsponding to the edge_lst 

    """ 
    edge_lst = []
    edge_length_lst = []
    for X in X_lst:
        nbs = find_nb(X, skeleton_arr)
        for nb in nbs:
            edge = [X, nb]
            no_loop = True
            extend_edge(edge, vertice_lst, skeleton_arr, no_loop)
            if no_loop:
                edge_lst.append(edge)
                edge_length_lst.append(len(edge))
            else: 
                if len(edge) > 8:
                    print(f"Be careful! A loop edge with length of {len(edge)} is found")
    #edge_lst_uniq, edge_length_lst_uniq = delete_two_v_loop(edge_lst)
    #return edge_lst_uniq, edge_length_lst_uniq
    return edge_lst, edge_length_lst

def delete_two_v_loop(edge_lst):
    end_lst = [[edge[0], edge[-1]] for edge in edge_lst]
    length_lst = [len(edge) for edge in edge_lst]
    #print(f"before, has {len(edge_lst)} edges")
    unique_group_lst = []
    for i, end_i in enumerate(end_lst):
        group = []
        for j, end_j in enumerate(end_lst):
            if end_i == end_j or end_i == [end_j[1], end_j[0]]:
                group.append(j)
        group.sort()
        if group not in unique_group_lst:
            unique_group_lst.append(group)
    kept_edge_lst = []
    for group in unique_group_lst:
        length_g = [length_lst[g] for g in group]
        idx_g = length_g.index(max(length_g))
        kept_idx = group[idx_g]                  
        kept_edge_lst.append(edge_lst[kept_idx])
    kept_length_lst = [len(edge) for edge in kept_edge_lst ]
    #print(f"after, has {len(kept_edge_lst)} edges")
    return kept_edge_lst, kept_length_lst 
            
            

def trim(skeleton_arr, length_threshold):
    """
    Trim off short branch edge whose length is less than threshold
    ----------
    skeleton_arr:    3D numpy array
                binary matrix with 1 for centerline
    length_threshold: integer
                When a branch edge has length under this threshold, it is cut off.
              
    Returns:
    ----------
    skeleton_trimmed:  3D numpy array
                skeleton without short branch.
                binary matrix with 1 for centerline

    """ 
    # find all vertices
    endpoint_lst, junction_lst = find_all_vertice(skeleton_arr)
    verice_lst = endpoint_lst + junction_lst
    
    #find all branch edges
    branch_lst, branch_length_lst = find_edges(endpoint_lst,verice_lst,skeleton_arr)
    
    delete_branch= []
    for i, length in enumerate(branch_length_lst):
        if length <= length_threshold:
            delete_branch.extend(branch_lst[i][:-1])
    delete_branch_arr = np.array(delete_branch)
    skeleton_trimmed = copy.deepcopy(skeleton_arr)
    if delete_branch_arr.size == 0:
        print("No short branch edge to be trimmed")
    else:      
        skeleton_trimmed[delete_branch_arr[:, 0], delete_branch_arr[:, 1], delete_branch_arr[:, 2]] = 0
    
    
    skeleton_trimmed = sk.skeletonize(skeleton_trimmed, method = 'lee')

    if np.max(skeleton_trimmed) == 255:
        skeleton_trimmed = skeleton_trimmed / 255
    return skeleton_trimmed



def all_paths_from_one_source(i, endpoint_lst, vertice_lst, path_length, path, final_path_lst, final_path_length_lst, weight_arr):
    """
    Given a  vertice (the i_th vertice in vertice_lst), find all paths starting from this vertice.
    A path is understood as combination of edges and must start from and end up at endpoint
    Parameters:
    ----------
    i:                integer
                     a index of vertice list
    endpoint_lst:         list of list
                     list of coordinates of all endpoints on skeleton
    vertice_lst :         list of list
                     list of coordinates of all vertices on skeleton  
    path_length :         integer
                     the length of path
    path:               list of integer
                     a path, represented by index of vertices on the path.
    final_path_lst :       list of list in integer
                     when a path has ended at an endpoint, add its path to the final_path_lst
    final_path_length_lst:   list of integer
                     the lengths of ended path 
               
    weight_arr:           V X V numpy array 
                      V is the number of vertices
                      weight_arr[i,j] represents the length of edge from vertice i to vertice j 
    Returns:
    ----------
    The function does not return anything.
    Instead, four parameters <path_length>, <path>, <final_path_lst>, <final_path_length_lst> are updated during recursion
    """ 
    V = len(vertice_lst)
    precursor_path = copy.copy(path)
    for j,vertice_j in enumerate(vertice_lst):
        # has met a junction and will continue
        if (weight_arr[i, j] > 0) and (j not in path) and (vertice_j not in endpoint_lst):
            new_path_length = path_length + weight_arr[i, j]
            new_path = precursor_path + [j]
            all_paths_from_one_source(j, endpoint_lst, vertice_lst, new_path_length, new_path, final_path_lst, final_path_length_lst,
                                      weight_arr)
        # has reached an endpoint, append this path to path list
        elif (weight_arr[i, j] > 0) and (j not in path) and (vertice_j in endpoint_lst):
            new_path_length = path_length + weight_arr[i, j]
            new_path = precursor_path + [j]
            final_path_lst.append(new_path)
            final_path_length_lst.append(path_length)
        # enter a loop, should stop tracing along this path
        elif (weight_arr[i, j] > 0) and (j in path[:-2]):
            pass


def longest_path_from_one_source(i, endpoint_lst, vertice_lst, weight_arr):
    """
    Given a  endpoint (the i_th endpoint in endpoint_lst), find the longest path starting from this endpoint
    Parameters:
    ----------
    i:                 integer
                     a index of endpoint list
    endpoint_lst:         list of list
                     list of coordinates of all endpoints on skeleton
    vertice_lst :         list of list
                     list of coordinates of all vertices on skeleton  
    weight_arr:           V X V numpy array 
                     V is the number of vertices
                     weight_arr[i,j] represents the length of edge from vertice i to vertice j 
    Returns:
    ----------
    longest_path :        list of integer
                    the longest path from the given point, 
                    a path is represented by index of vertices on the path. 
    longest_length :      interger
                    the length of the longest path

    """ 
    path_length = 0
    path = [i]
    final_path_lst, final_path_length_lst = [[]], []
    all_paths_from_one_source(i, endpoint_lst, vertice_lst, path_length, path, final_path_lst, final_path_length_lst, weight_arr)
    # find the longest path  from the path list
    path_length_arr = np.array(final_path_length_lst)
    idx = np.argmax(path_length_arr)
    longest_path = final_path_lst[idx]
    longest_length = np.max(path_length_arr)
    return longest_path, longest_length


def trunk(skeleton_arr):
    """
    Keep only the trunk of skeleton and delete other points
    ----------
    skeleton_arr:    3D numpy array
                binary matrix with 1 for centerline    
    Returns:
    ----------
    trunk_skeleton :  3D numpy array
                the longest path in skeleton
                binary matrix with 1 for centerline

    """ 
    size = skeleton_arr.shape
    
    # vertex list
    v_end, v_junction = find_all_vertice(skeleton_arr)
    End = len(v_end)
    vertice_lst = v_end + v_junction
    V = len(vertice_lst)
    #print(f"The number of end point is {End} and no. of vertice is {V}")
    
    # edge list
    edge_lst , edge_length_lst = find_edges(vertice_lst, vertice_lst, skeleton_arr)
    #print("The number of edge is ", len(edge_lst))
    
    # contruct weight matrix
    weight_arr = np.zeros((V, V))
    for i, edge in enumerate(edge_lst):
        edge_length = len(edge)
        assert edge[0] in vertice_lst and edge[-1] in vertice_lst
        p = vertice_lst.index(edge[0])
        q = vertice_lst.index(edge[-1])
        weight_arr[p, q] = edge_length
        weight_arr[q, p] = edge_length
    
    # find the longest for each endpoint.
    path_ii_lst, path_length_ii_lst = [], []
    for ii in range(End):
        path_ii, path_length_ii = longest_path_from_one_source(ii, v_end, vertice_lst, weight_arr)
        path_ii_lst.append(path_ii)
        path_length_ii_lst.append(path_length_ii)
        #print(f"{ii} vertice have been examined ")

    # choose the longest path amonge all endpoints
    max_path_length = max(path_length_ii_lst)
    idx_vertice_in_longest_path = path_ii_lst[path_length_ii_lst.index(max_path_length)]
    vertice_in_longest_path = [vertice_lst[v] for v in idx_vertice_in_longest_path]
    #print(f"{len(vertice_in_longest_path)} vertices in longest path")
    
    # all points on the longest path
    points_in_longest_path = []
    for i, vertice in enumerate(vertice_in_longest_path[:-1]):
        vertice_next = vertice_in_longest_path[i+1]
        for edge in edge_lst:
            if (edge[0] == vertice and edge[-1] == vertice_next) or (edge[0] == vertice_next and edge[-1] == vertice):
                points_in_longest_path.extend(edge)
                
    # keep only the trunk
    point = np.array(points_in_longest_path)
    trunk_skeleton = np.zeros((size))
    trunk_skeleton[point[:, 0], point[:, 1], point[:, 2]] = 1

    return trunk_skeleton

def trunk_of_skeleton(colon, affine):
    """
    Detect the centerline of colon. 
    Start from calculating the skeleton, followed by cutting off short branches and finding the longest path
    Parameters:
    ----------
    colon :        3D numpy array
                a binary array in voxel coordinate system
    affine :       4 X 4 numpy array 
                the affine array
    Returns:
    ----------
    skeleton_points : N X 3 numpy array
                The coordinates of points on the trunk
    """
    
    skeleton, origin = find_skeleton(colon, affine)
    plot_skeleton(skeleton, origin)
    #trim
    skeleton_trim = trim(skeleton, length_threshold = 30)
    plot_skeleton(skeleton_trim, origin)
    #trunk
    skeleton_trunk=trunk(skeleton_trim)
    plot_skeleton(skeleton_trunk, origin)
    
    skeleton_points = np.argwhere(skeleton_trunk == 1) + origin
    return skeleton_points


def take_sg_from_skeleton(skeleton_points, chosen_sg):
    """
    Extract only a segment of centerline
    Parameters:
    ----------
    skeleton_points : N X 3 numpy array
                The coordinates of points on the centerline
    chosen_sg :     a tuple of six floats
                (x_low, x_high, y_low, y_high, z_low, z_high)
                the border, within of which centerlien will be perserved.
    
    Returns:
    ----------
    points_sg :     N X 3 numpy array
                The coordinates of points on the segment of centerline

    """
    x_a, x_b, y_a, y_b, z_a, z_b = chosen_sg
    x_select = (skeleton_points[:,0] >= x_a) & (skeleton_points[:,0] <= x_b)
    y_select = (skeleton_points[:,1] >= y_a) & (skeleton_points[:,1] <= y_b)
    z_select = (skeleton_points[:,2] >= z_a) & (skeleton_points[:,2] <= z_b)
    select = x_select & y_select & z_select   
    points_sg = skeleton_points[select]
    return points_sg
